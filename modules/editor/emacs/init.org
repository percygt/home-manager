#+TITLE: My emacs literate configuration
#+AUTHOR: PercyGT

This org file is used as the configuration source for my emacs. Additional packages may be found at emacs.nix (those that cannot be directly installed from =use-package=). Though declared in emacs lisp, they actually are completely managed by the =nix= package manager, by parsing the declarations on this file and using them to fetch the packages, which I think is really cool.

This makes it such that it is trivial to handle complex configurations, such as pylsp with plugins or treesitter grammars installation process (which usually envolves some stateful installations outside of emacs).

In order to run this emacs configuration locally, all you need to do is run the following command:
#+begin_src shell
nix run github:o-santi/emacs --experimental-features "nix-command" --experimental-features "flakes"
#+end_src
Though you probably shouldn't, because it will most likely build all of emacs from scratch (which takes a little while).

You can also use it as a ~nixosModule~, in order to add additional packages like fonts.

* Core
** Vanilla Emacs
   #+begin_src emacs-lisp :tangle yes
   (use-package emacs
     :ensure nil
     :demand
     :preface
     (defun indicate-buffer-boundaries-left ()
       (setq indicate-buffer-boundaries 'left))
     :custom
     (initial-scratch-message               nil)
     (inhibit-startup-screen                t) ;; Don't show the welcome splash screen.
     (tab-width                             4) ;; Set tab-size to 4 spaces
     (delete-by-moving-to-trash             t)
     (visible-bell                          t)
     (x-stretch-cursor                      t)
     (mouse-yank-at-point                   t)
     (use-short-answers                     t)
     (column-number-mode                    t)
     (indent-tabs-mode                      nil) ;; Always indent with spaces
     (even-window-sizes                     nil)
     (confirm-kill-processes                nil)
     (fill-column                           100)
     (tab-always-indent                     'complete)
     (large-file-warning-threshold          nil)
     (byte-compile-warnings                 '(ck-functions))
     (cursor-in-non-selected-windows        nil)
     (completion-cycle-threshold            3)
     (completion-ignore-case                t)
     (read-buffer-completion-ignore-case    t)
     (read-file-name-completion-ignore-case t)
     (max-lisp-eval-depth                   10000)
     (scroll-margin                         0)
     (fast-but-imprecise-scrolling          t)
     (scroll-preserve-screen-position       t)
     (debug-on-error                        nil)
     (auto-window-vscroll                   nil)
     (warning-minimum-level                 :emergency)
     (ad-redefinition-action                'accept)
     (auto-revert-check-vc-info             t)
     (echo-keystrokes                       0.2)
     (font-lock-maximum-decoration          t)
     (highlight-nonselected-windows         t)
     (kill-buffer-query-functions           nil) ;; Dont ask for closing spawned processes
     (use-dialog-box                        nil)
     (word-wrap                             nil)
     (auto-mode-case-fold                   nil)
     (undo-limit                            (* 16 1024 1024)) ;; 64mb
     (undo-strong-limit                     (* 24 1024 1024)) ;; x 1.5 (96mb)
     (undo-outer-limit                      (* 24 1024 1024)) ;; x 10 (960mb), (Emacs uses x100), but this seems too high.
     (jit-lock-defer-time                   0)
     (text-mode-ispell-word-completion      nil)
     (read-extended-command-predicate       #'command-completion-default-include-p)
     :hook ((prog-mode . display-fill-column-indicator-mode)
            ((prog-mode text-mode) . indicate-buffer-boundaries-left)))

    (use-package diminish :after use-package) ;; if you use :diminish
    #+end_src

** Display line numbers
  #+begin_src emacs-lisp :tangle yes
  (use-package display-line-numbers
    :ensure nil
    :custom
    (display-line-numbers-grow-only   t)
    (display-line-numbers-width-start t)
    (display-line-numbers-type        'relative)
    :hook (((text-mode prog-mode conf-mode) . display-line-numbers-mode)
         (org-mode . (lambda () (display-line-numbers-mode -1)))))
  #+end_src
** No littering
  (use-package no-littering
   :demand
   :custom
     (no-littering-etc-directory user-emacs-data-directory)
     (no-littering-var-directory user-emacs-data-directory))
  #+begin_src emacs-lisp :tangle yes
  #+end_src

** Files
#+begin_src emacs-lisp :tangle yes
(use-package files
  :after no-littering
  :ensure nil
  :demand
  :preface
  (defvar backup-dir (no-littering-expand-var-file-name "backup/")
    "Directory to store backups.")
  (defvar auto-save-dir (no-littering-expand-var-file-name "auto-save/")
    "Directory to store auto-save files.")
  (defvar customfile (no-littering-expand-etc-file-name "custom.el")
    "Custom file")
  :init
  (unless (file-exists-p auto-save-dir) (make-directory auto-save-dir t))
  (unless (file-exists-p backup-dir) (make-directory backup-dir t))
  (when (file-exists-p customfile) (load customfile))
  :config
  (global-hl-line-mode 1)           ; Highlight the current line to make it more visible
  :custom
  (create-lockfiles                 nil)
  (make-backup-files                nil)
  (user-emacs-directory             user-emacs-data-directory)
  (backup-directory-alist           `(("\\`/tmp/" . nil)
                                      ("\\`/dev/shm/" . nil)
                                      (".*" . ,backup-dir)))
  (auto-save-file-name-transforms   `((".*" ,auto-save-dir t)))
  (custom-file                      customfile)
  (auto-save-no-message             t)
  (auto-save-interval               100)
  (find-file-visit-truename          t)
  (backup-by-copying                t)    ; Always use copying to create backup files
  (delete-old-versions              t)    ; Delete excess backup versions
  (kept-new-versions                6)    ; Number of newest versions to keep when a new backup is made
  (kept-old-versions                2)    ; Number of oldest versions to keep when a new backup is made
  (version-control                  t)    ; Make numeric backup versions unconditionally
  (delete-by-moving-to-trash        t)    ; Move deleted files to the trash
  (mode-require-final-newline       nil))  ; Don't add newlines at the end of files

#+end_src

** Auto Revert
#+begin_src emacs-lisp :tangle yes
(use-package autorevert
  :ensure nil
  :defer 2
  :custom (auto-revert-verbose nil)
  :diminish auto-revert-mode)
#+end_src

** Save History
#+begin_src emacs-lisp :tangle yes
(use-package savehist
  :ensure nil
  :hook (after-init . savehist-mode))
#+end_src

** Recent File
#+begin_src emacs-lisp :tangle yes
(use-package recentf
  :ensure nil
  :defer 2
  :custom
  (recentf-max-saved-items 1000)
  (recentf-exclude `("/tmp/" "/ssh:" "/nix/store"
		             ,(concat user-emacs-data-directory "lib/.*-autoloads\\.el\\'")))
  :config
  (add-to-list 'recentf-exclude (recentf-expand-file-name no-littering-etc-directory))
  (add-to-list 'recentf-exclude (recentf-expand-file-name no-littering-var-directory))
  (recentf-mode))
#+end_src

** Eldo
#+begin_src emacs-lisp :tangle yes
(use-package eldoc
  :ensure nil
  :diminish eldoc-mode)
#+end_src

** Undo
#+begin_src emacs-lisp :tangle yes
(use-package undo-fu
  :after evil
  :config
  (setq undo-fu-allow-undo-in-region t))

(use-package undo-fu-session
  :hook (after-init . undo-fu-session-global-mode)
  :custom
  (undo-fu-session-directory (expand-file-name  "var/undo-fu-session/" user-emacs-data-directory))
  (undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))
#+end_src

** Window
    #+begin_src emacs-lisp :tangle yes
    (use-package window
      :ensure nil
      :after (evil)
      :bind
      :custom
      (display-buffer-alist
       '(("\\*Async Shell Command\\*"
          (display-buffer-no-window))
         ("\\*Faces\\|[Hh]elp\\*"
          (display-buffer-in-side-window)
          (body-function . select-window)
          (window-width . 0.4)
          (side . right)
          (slot . 1))
         ("\\*e?shell\\|*ellama\\|\\*vterm\\*"
          (display-buffer-in-side-window)
          (body-function . select-window)
          (window-height . 0.13)
          (window-parameters . ((mode-line-format . none)))
          (side . bottom)
          (slot . 10))
         ("\\*Flycheck\\|[Cc]olors\\*\\|Warnings"
          (display-buffer-in-side-window display-buffer-reuse-window)
          (body-function . select-window)
          (display-buffer-at-bottom)
          (window-height . 0.15)
          (side . bottom)
          (slot . 3))))
      :init
      (defvar splitscreen/mode-map (make-sparse-keymap))
      (define-prefix-command 'splitscreen/prefix)
      (define-key splitscreen/mode-map (kbd "C-w") 'splitscreen/prefix)

      (defun splitscreen/window-left () (interactive) (evil-window-left 1))
      (defun splitscreen/window-right () (interactive) (evil-window-right 1))
      (defun splitscreen/window-up () (interactive) (evil-window-up 1))
      (defun splitscreen/window-down () (interactive) (evil-window-down 1))

      (defun splitscreen/increase-width () (interactive) (evil-window-increase-width 10))
      (defun splitscreen/decrease-width () (interactive) (evil-window-decrease-width 10))
      (defun splitscreen/increase-height () (interactive) (evil-window-increase-height 10))
      (defun splitscreen/decrease-height () (interactive) (evil-window-decrease-height 10))

      ;; We override these. Just declare them as part of the splitscreen map, not
      ;; evil-window-map.
      (define-key evil-window-map (kbd "h") nil)
      (define-key evil-window-map (kbd "j") nil)
      (define-key evil-window-map (kbd "k") nil)
      (define-key evil-window-map (kbd "l") nil)
      (define-key evil-window-map (kbd "n") nil)
      (define-key evil-window-map (kbd "p") nil)
      (define-key evil-window-map (kbd "c") nil)
      (define-key evil-window-map (kbd "C-h") nil)
      (define-key evil-window-map (kbd "C-j") nil)
      (define-key evil-window-map (kbd "C-k") nil)
      (define-key evil-window-map (kbd "C-l") nil)
      (define-key evil-window-map (kbd "l") nil)
      (define-key evil-window-map (kbd "o") nil)
      (define-key evil-window-map (kbd "v") nil)
      (define-key evil-window-map (kbd "s") nil)
      (define-key evil-window-map (kbd "q") nil)
      (define-key evil-window-map (kbd "w") nil)

      (define-key splitscreen/prefix (kbd "h") 'splitscreen/window-left)
      (define-key splitscreen/prefix (kbd "j") 'splitscreen/window-down)
      (define-key splitscreen/prefix (kbd "k") 'splitscreen/window-up)
      (define-key splitscreen/prefix (kbd "l") 'splitscreen/window-right)

      (define-key splitscreen/prefix (kbd "C-h") 'splitscreen/decrease-width)
      (define-key splitscreen/prefix (kbd "C-j") 'splitscreen/decrease-height)
      (define-key splitscreen/prefix (kbd "C-k") 'splitscreen/increase-height)
      (define-key splitscreen/prefix (kbd "C-l") 'splitscreen/increase-width)
      (define-key splitscreen/prefix (kbd "s-h") 'splitscreen/decrease-width)
      (define-key splitscreen/prefix (kbd "s-j") 'splitscreen/decrease-height)
      (define-key splitscreen/prefix (kbd "s-k") 'splitscreen/increase-height)
      (define-key splitscreen/prefix (kbd "s-l") 'splitscreen/increase-width)

      (define-key splitscreen/prefix (kbd "v") 'split-window-right)
      (define-key splitscreen/prefix (kbd "s") 'split-window-below)
      (define-key splitscreen/prefix (kbd "q") 'delete-window)
      (define-key splitscreen/prefix (kbd "w") 'window-toggle-side-windows)
      (define-key splitscreen/prefix (kbd "Q") 'kill-buffer-and-window)
      (define-key splitscreen/prefix (kbd "SPC") 'balance-windows)

      (define-minor-mode splitscreen-mode
        "Provides tmux-like bindings for managing windows and buffers.
                     See https://github.com/mattduck/splitscreen"
        :init-value 1 ; enable by default
        :global 1
        :keymap splitscreen/mode-map))
    #+end_src
** Dired
  #+begin_src emacs-lisp :tangle yes
  (use-package dired
    :ensure nil
    :custom ((dired-listing-switches "-agho --group-directories-first"))
    :general
    (normal-definer
      :keymaps '(dired-mode-map)
      "L" 'nil
      "H" 'nil
      "D" 'nil
      "d" 'nil
      "r" 'dired-do-rename
      "R" 'dired-do-redisplay
      "y" 'dired-do-copy
      "d" 'dired-do-delete))

  (use-package dired-single
    :after dired
    :general
    (normal-definer
      :keymaps '(dired-mode-map)
      "l" 'dired-single-buffer
      "h" 'dired-single-up-directory))

  (use-package diredfl
    :after dired
    :hook (dired-mode . diredfl-global-mode))

  (use-package dired-open
    :after dired
    :custom
    (dired-open-extensions '(("png" . "feh")
                             ("mkv" . "mpv"))))

  (use-package dired-hide-dotfiles
    :general
    (normal-definer
      :keymaps '(dired-mode-map)
      "SPC" 'nil
      "."   'dired-hide-dotfiles-mode))
  #+end_src
* Keybindings
** General
#+begin_src emacs-lisp :tangle yes
(use-package general
  :demand t
  :preface
  (defun switch-to-recent-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer))))
  (defun kill-this-buffer ()  ; for the menu bar
    "Kill the current buffer.
When called in the minibuffer, get out of the minibuffer
using `abort-recursive-edit'."
    (interactive)
    (cond
     ;; Don't do anything when `menu-frame' is not alive or visible
     ;; (Bug#8184).
     ((not (menu-bar-menu-frame-live-and-visible-p)))
     ((menu-bar-non-minibuffer-window-p)
      (kill-buffer (current-buffer)))
     (t
      (abort-recursive-edit))))
  :config
  (general-override-mode)
  (general-auto-unbind-keys)
  (general-create-definer global-definer
    :keymaps 'override
    :states '(insert normal hybrid motion visual operator emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")
  (general-create-definer local-definer
    :keymaps 'override
    :states '(insert normal hybrid motion visual operator emacs)
    :prefix ","
    :global-prefix "C-,")
  (general-create-definer normal-definer
    :keymaps 'override
    :states '(normal))

  (normal-definer
    "D" 'kill-this-buffer)
  (global-definer
    "!" 'shell-command
    ":" 'eval-expression
    "f" 'find-file
    "l" 'load-file
    "d" 'dired
    "." 'switch-to-recent-buffer
    "u"  '(nil :wk "Utils")
    "u." 'repeat
    )

  (general-create-definer global-leader
    :keymaps 'override
    :states '(insert normal hybrid motion visual operator)
    :prefix "SPC m"
    :non-normal-prefix "C-SPC m"
    "" '( :ignore t
  	      :which-key
  	      (lambda (arg)
  	        (cons (cadr (split-string (car arg) " "))
  		          (replace-regexp-in-string "-mode$" "" (symbol-name major-mode))))))
  )
#+end_src

** Evil
#+begin_src emacs-lisp :tangle yes
(use-package evil
  :preface
  (defun evil-insert-jk-for-normal-mode ()
    (interactive)
    (insert "j")
    (let ((event (read-event nil)))
      (if (= event ?k)
          (progn
            (backward-delete-char 1)
            (evil-normal-state))
	    (push event unread-command-events))))
  :init
  (setq evil-want-keybinding      nil)
  (setq evil-want-integration     t)
  (setq evil-emacs-state-cursor  '("white" box))
  (setq evil-normal-state-cursor '("cyan" box))
  (setq evil-visual-state-cursor '("pale goldenrod" box))
  (setq evil-insert-state-cursor '("sky blue" bar))
  :custom
  (evil-want-fine-undo           t)
  (evil-respect-visual-line-mode t)
  (evil-want-C-u-scroll          t)
  (evil-want-C-i-jump            nil)
  (evil-search-module            'evil-search)
  (evil-undo-system              'undo-fu)
  (evil-split-window-right       t)
  (evil-split-window-below       t)
  (evil-want-Y-yank-to-eol       t)
  :hook ((custom-mode
          eshell-mode
          git-rebase-mode
          term-mode) . evil-emacs-state-mode)
  :bind ( :map evil-normal-state-map
	      ("C-e" . evil-end-of-line)
	      ("C-b" . evil-beginning-of-line)
	      ("ESCAPE" . keyboard-escape-quit)
	      ("WW" . save-buffer)
	      :map evil-insert-state-map
	      ("j"   . evil-insert-jk-for-normal-mode)
	      :map evil-visual-state-map
	      ("ESCAPE" . keyboard-quit)
	      :map special-mode-map
	      ("q" . quit-window))
  :config
  (evil-mode 1)
  (evil-set-initial-state 'messages-buffer-mode 'normal))

(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))

(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))

(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode))

(use-package evil-goggles
  :init
  (evil-goggles-mode)
  :after evil
  :config
  (setq evil-goggles-pulse t
        (evil-goggles-use-diff-faces))
        evil-goggles-duration 0.3)

(use-package avy
  :bind (:map evil-normal-state-map
              ("M-s" . avy-goto-char)))

(use-package move-text
  :bind (:map evil-normal-state-map
              ("M-k" . move-text-up)
	          ("M-j" . move-text-down))
  :config
  (move-text-default-bindings))
#+end_src
* Languages
I try to mostly use the new Treesitter modes, which comes builtin with the new emacs 29.
** Python
The package already comes builtin, so we only instantiate it to define the hooks and remap the default package for the new one.

It also relies on python lsp server with builtin ruff support.
#+begin_src emacs-lisp :tangle yes
(add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
(add-hook 'python-ts-mode-hook #'eglot-ensure)
#+end_src

** Nix
#+begin_src emacs-lisp :tangle yes
(use-package nix-mode
  :hook (nix-mode . eglot-ensure))
#+end_src
** Rust
Try to use the package.
#+begin_src emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
(add-hook 'rust-ts-mode-hook #'eglot-ensure)

(setq rust-ts-mode-indent-offset 2)
#+end_src

** Markdown
#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :mode "\\.md\\'")
#+end_src
** Coq
#+begin_src emacs-lisp :tangle yes
(use-package proof-general
  :custom
  (proof-splash-enable nil))

(use-package company-coq
  :hook (coq-mode . company-coq-mode))
#+end_src
